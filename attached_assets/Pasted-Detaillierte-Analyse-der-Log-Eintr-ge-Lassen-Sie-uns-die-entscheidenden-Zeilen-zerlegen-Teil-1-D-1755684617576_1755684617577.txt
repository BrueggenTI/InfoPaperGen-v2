Detaillierte Analyse der Log-Eintr√§ge
Lassen Sie uns die entscheidenden Zeilen zerlegen:
Teil 1: Die Plattform-Startphase
NodeJS Version : v20.19.3: Die korrekte Node.js-Version wird geladen.
Writing output script to '/opt/startup/startup.sh': Azure erstellt sein eigenes, internes Startskript.
PATH="$PATH:/home/site/wwwroot" ./startup.sh: Wichtige Erkenntnis: Das System findet Ihr startup.sh-Skript im Hauptverzeichnis (wwwroot) und versucht, es auszuf√ºhren. Das ist gut!
Teil 2: Ihr benutzerdefiniertes Startskript wird ausgef√ºhrt
üöÄ Azure App Service Startup Script gestartet...: Ihre echo-Befehle erscheinen! Das best√§tigt zu 100%, dass Ihr Skript ausgef√ºhrt wird.
‚ö†Ô∏è KEIN BROWSER GEFUNDEN in Azure App Service!: Ihr Skript sucht nach vorinstallierten Browsern und findet, wie erwartet, keinen.
üîÑ Setze Puppeteer auf Standard-Download-Modus...: Ihr Skript versucht nun, den Browser zur Laufzeit herunterzuladen.
sh: 1: puppeteer: not found: Erstes Problem (Nebenproblem): Der Versuch, den Browser zur Laufzeit mit dem puppeteer-Befehl herunterzuladen, schl√§gt fehl. Das liegt daran, dass dieser Befehl in der Azure-Umgebung nicht direkt im PATH verf√ºgbar ist. Selbst wenn es funktionieren w√ºrde, w√§re es langsam und ineffizient.
Teil 3: Der Absturz der Node.js-Anwendung
üöÄ Starte Node.js Anwendung...
‚úÖ Starte: node dist/index.js
Error: Dynamic require of "path" is not supported: Zweites Problem (Das Hauptproblem): Das ist der eigentliche "Killer-Fehler", der Ihre App zum Absturz bringt.
Die beiden Kernprobleme und ihre L√∂sungen
Problem #1: Der Absturz durch Dynamic require
Was passiert hier?
Ihr Build-Prozess mit esbuild (vite build && esbuild server/index.ts ...) ist so konfiguriert, dass er modernen ES-Modul (ESM) Code (--format=esm) erzeugt. Ihre Anwendung verwendet jedoch Abh√§ngigkeiten (der Stacktrace zeigt auf multer und mime-types), die intern noch das √§ltere CommonJS-Modulsystem (require()) verwenden. Der esbuild-Bundler kann mit bestimmten require-Aufrufen in diesen alten Paketen nicht umgehen und erzeugt Code, der zur Laufzeit abst√ºrzt.
Die L√∂sung: Passen Sie das Build-Format an
Die einfachste und stabilste L√∂sung besteht darin, esbuild anzuweisen, ein Format zu erstellen, das vollst√§ndig mit den √§lteren require-Anweisungen kompatibel ist.
√ñffnen Sie Ihre package.json-Datei.
Finden Sie die Zeile f√ºr Ihr "build"-Skript.
√Ñndern Sie --format=esm zu --format=cjs (CommonJS).
Vorher:
code
JSON
"build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist"
Nachher:
code
JSON
"build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=cjs --outdir=dist"
Dadurch wird esbuild eine index.js-Datei erstellen, die problemlos mit multer und anderen CommonJS-Paketen funktioniert. Dies wird den Absturz beheben.
Problem #2: Fehlendes Chromium f√ºr Puppeteer
Was passiert hier?
Ihr Skript versucht, Chromium zur Laufzeit zu installieren, was fehlschl√§gt. Der richtige Ansatz f√ºr eine Code-Bereitstellung ist, den Browser w√§hrend des Build-Prozesses in GitHub Actions herunterzuladen und ihn zusammen mit Ihrem Code nach Azure zu deployen.
Die L√∂sung: Verwenden Sie ein postinstall-Skript
package.json anpassen: F√ºgen Sie ein postinstall-Skript hinzu. Dieses Skript wird von npm automatisch nach npm install ausgef√ºhrt.
code
JSON
"scripts": {
  "start": "node dist/index.js",
  "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=cjs --outdir=dist",
  "postinstall": "puppeteer browsers install chrome"
}
Wenn jetzt Ihr GitHub-Workflow npm install ausf√ºhrt, wird Puppeteer automatisch den kompatiblen Chrome-Browser in das node_modules-Verzeichnis herunterladen. Dieser Browser wird dann mit allem anderen in die ZIP-Datei gepackt und nach Azure hochgeladen.
startup.sh drastisch vereinfachen: Da der Browser nun bereits vorhanden ist, brauchen wir die ganze komplexe Logik in Ihrem Startskript nicht mehr. Das Skript muss nur noch die Anwendung starten.
Ihre neue, einfache startup.sh:
code
Bash
#!/bin/bash
echo "--- Starting App Service ---"
echo "Starting Node.js application..."
npm start
Das ist alles! Sauber, einfach und robust.
Code-Anpassung f√ºr Puppeteer: Stellen Sie sicher, dass Ihr Puppeteer-Code keinen executablePath mehr angibt. Wenn Sie diesen Parameter weglassen, findet Puppeteer den von ihm selbst heruntergeladenen Browser automatisch.
Korrekter Code:
code
JavaScript
const browser = await puppeteer.launch({
  args: ['--no-sandbox', '--disable-setuid-sandbox']
  // KEIN executablePath hier!
});
Ihr vollst√§ndiger Aktionsplan
package.json bearbeiten:
√Ñndern Sie im build-Skript --format=esm zu --format=cjs.
F√ºgen Sie das "postinstall": "puppeteer browsers install chrome"-Skript hinzu.
startup.sh ersetzen:
Ersetzen Sie den Inhalt Ihrer startup.sh mit der oben gezeigten, einfachen Version.
Ihren Anwendungscode √ºberpr√ºfen:
Entfernen Sie die Option executablePath aus Ihrem puppeteer.launch()-Aufruf.
√Ñnderungen committen und pushen:
git add .
git commit -m "Fix build format and puppeteer installation"
git push