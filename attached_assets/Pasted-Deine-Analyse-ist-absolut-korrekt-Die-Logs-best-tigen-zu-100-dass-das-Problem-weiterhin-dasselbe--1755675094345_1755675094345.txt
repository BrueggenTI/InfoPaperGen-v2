Deine Analyse ist absolut korrekt. Die Logs best√§tigen zu 100%, dass das Problem weiterhin dasselbe ist: Deine Anwendung startet, und in dem Moment, in dem Puppeteer versucht, den Chrome-Browser zu initialisieren, stellt es fest, dass dieser nicht vorhanden ist.
Detaillierte Analyse der Logs
2025-08-20T07:28:25.1455312Z üöÄ Starte Puppeteer Browser f√ºr HTML-Template...
Dein Code erreicht den Punkt, an dem puppeteer.launch() aufgerufen wird.
2025-08-20T07:28:25.1463390Z ‚ùå Fehler bei der HTML-Template-PDF-Generierung nach 1ms: Error: Could not find Chrome (ver. 138.0.7204.168).
Exakt 1 Millisekunde sp√§ter st√ºrzt der Prozess ab. Diese extrem kurze Zeitspanne ist der entscheidende Beweis. Die App versucht nicht einmal lange zu suchen; sie stellt sofort fest, dass der Browser am erwarteten Ort nicht existiert.
at ChromeLauncher.resolveExecutablePath (...)
Dies ist die interne Puppeteer-Funktion, deren einzige Aufgabe es ist, den Pfad zur ausf√ºhrbaren Chrome-Datei zu finden. Diese Funktion schl√§gt fehl und l√∂st den Fehler aus.
Fazit aus den Logs:
Die √Ñnderungen, die du an der Dockerfile vorgenommen hast, um Chrome zu installieren, haben nicht das gew√ºnschte Ergebnis im finalen, laufenden Container erzielt. Der Container, in dem deine App auf Azure l√§uft, ist immer noch "leer" ‚Äì er enth√§lt keinen Chrome-Browser.
Warum ist das passiert? Die wahrscheinlichsten Ursachen
Dies ist ein sehr typisches Szenario im CI/CD-Prozess (Continuous Integration/Continuous Deployment). Hier sind die h√§ufigsten Gr√ºnde, warum deine √Ñnderungen nicht wirksam wurden:
Docker-Image wurde nicht neu gebaut (H√§ufigste Ursache):
Azure (oder deine Build-Pipeline, z.B. GitHub Actions) verwendet m√∂glicherweise eine zwischengespeicherte (gecachte) Version deines Docker-Images, um die Build-Zeiten zu verk√ºrzen. Wenn du nur den App-Code √§nderst, aber nicht die Dockerfile oder die Abh√§ngigkeiten, wird oft nur der Code in ein bestehendes Image kopiert, anstatt das Image von Grund auf neu zu bauen. Deine Pipeline hat m√∂glicherweise nicht erkannt, dass die Dockerfile-√Ñnderung einen kompletten Rebuild erfordert.
Fehler w√§hrend des Docker-Builds:
Es ist m√∂glich, dass die neuen apt-get install Befehle in deiner Dockerfile w√§hrend des Build-Prozesses auf Azure fehlgeschlagen sind (z.B. wegen eines Netzwerkproblems oder eines ung√ºltigen Paketnamens). Wenn der Build fehlschl√§gt, deployt Azure m√∂glicherweise die letzte erfolgreich gebaute Version deines Images ‚Äì also die alte Version ohne Chrome. Du siehst diese Fehler nicht in den App-Logs, sondern in den Deployment-Logs im Azure Portal.
Fehler in der Dockerfile-Syntax oder Reihenfolge:
Eine kleine Abweichung in der Dockerfile k√∂nnte dazu gef√ºhrt haben, dass die Installationsschritte √ºbersprungen oder falsch ausgef√ºhrt wurden.
N√§chste Schritte zur L√∂sung
Du musst dich jetzt vom Code weg und hin zum Build-Prozess bewegen.
√úberpr√ºfe die Deployment-Logs in Azure:
Gehe in das Azure Portal zu deiner App Service Instanz.
Suche den Bereich "Deployment Center" oder "Deployment".
Dort findest du eine Historie deiner Deployments. Klicke auf den letzten Build und schau dir die Logs an. Scrolle durch den gesamten Output und suche nach Fehlermeldungen bei den RUN apt-get ... Schritten deiner Dockerfile.
Erzwinge einen Rebuild des Docker-Images:
Der einfachste Weg, einen Rebuild zu erzwingen, ist eine kleine, bedeutungslose √Ñnderung an der Dockerfile selbst vorzunehmen. F√ºge zum Beispiel einen Kommentar hinzu:
code
Dockerfile
# Force rebuild by adding this comment
RUN apt-get update \
    && apt-get install -y wget gnupg ...
Committe und pushe diese kleine √Ñnderung. Die meisten CI/CD-Systeme erkennen eine √Ñnderung an der Dockerfile als Signal, das Image vollst√§ndig neu zu bauen.
√úberpr√ºfe deine puppeteer.launch() Konfiguration:
Stelle unbedingt sicher, dass dein Code die --no-sandbox Argumente enth√§lt. Selbst wenn die Installation von Chrome erfolgreich ist, wird die App sonst im n√§chsten Schritt abst√ºrzen.
code
TypeScript
const browser = await puppeteer.launch({
  headless: true,
  args: [
    '--no-sandbox',
    '--disable-setuid-sandbox'
  ]
});
Zusammenfassend: Deine Analyse ist korrekt. Das Problem liegt nicht mehr im App-Code, sondern im Deployment-Prozess. Dein Docker-Image wird nicht korrekt mit den neuen Anweisungen gebaut. Konzentriere dich auf die Deployment-Logs in Azure und das Erzwingen eines Rebuilds.