Hallo, ich habe in diesem Repl eine Node.js-Anwendung entwickelt. Diese Anwendung hat die folgenden Kernfunktionen:
Eine OpenAI-Integration zur Nutzung von KI-Funktionen.
Eine PDF-Generierung mittels Puppeteer und Chromium.
Mein Ziel ist es, diese Anwendung als Docker-Container auf Azure bereitzustellen. Der Deployment-Prozess soll über GitHub Actions automatisiert werden, sobald ich Änderungen in mein GitHub-Repository pushe.
Bitte konfiguriere mein Projekt für dieses Vorhaben optimal. Erstelle und konfiguriere dazu die folgenden Dateien und gib mir eine schrittweise Anleitung für die Dinge, die ich manuell in Azure und GitHub erledigen muss.
1. Dockerfile erstellen und konfigurieren
Erstelle ein Dockerfile im Hauptverzeichnis meines Projekts. Dieses Dockerfile soll:
Ein passendes Node.js-Basisimage verwenden (z.B. node:18-slim).
Alle notwendigen Abhängigkeiten für Puppeteer und Chromium in einer Linux-Umgebung installieren. Die Installation von Chromium sollte explizit erfolgen, um Kompatibilitätsprobleme zu vermeiden.[1][2][3][4]
Den PUPPETEER_SKIP_CHROMIUM_DOWNLOAD Environment-Variable auf true setzen, da wir Chromium manuell installieren.[1][3]
Meine Anwendungsdateien in das Container-Image kopieren.
Die npm-Abhängigkeiten installieren.
Den Port freigeben, auf dem meine Anwendung läuft (z.B. 8080).
Den Startbefehl für meine Anwendung definieren.
Stelle sicher, dass die Puppeteer-Konfiguration im Code so angepasst wird, dass sie den Pfad zum manuell installierten Chromium (/usr/bin/google-chrome) verwendet und mit den --no-sandbox Args gestartet wird.[3][5]
2. GitHub Actions Workflow für CI/CD erstellen
Erstelle eine GitHub Actions Workflow-Datei unter .github/workflows/main.yml. Dieser Workflow soll:
Bei jedem Push in den main-Branch meines GitHub-Repositorys getriggert werden.[6][7]
Die folgenden Schritte ausführen:
Den Code aus dem Repository auschecken.
Sich bei meiner Azure Container Registry (ACR) anmelden. Die Zugangsdaten (Benutzername und Passwort) sollen über GitHub Secrets bereitgestellt werden.
Das Docker-Image basierend auf dem Dockerfile bauen.
Das gebaute Image mit einem eindeutigen Tag (z.B. dem GitHub Commit SHA) versehen und in meine Azure Container Registry pushen.
Sich bei Azure mit den Anmeldeinformationen eines Service Principals anmelden, die ebenfalls als GitHub Secret gespeichert sind.[8][9]
Das neu gebaute Docker-Image in einer Azure Container App oder einer Azure Web App for Containers bereitstellen. Der Workflow soll die vorhandene Azure-Ressource aktualisieren.[7]
Bitte füge Kommentare in die Workflow-Datei ein, die erklären, welche GitHub Secrets ich erstellen muss (z.B. ACR_USERNAME, ACR_PASSWORD, AZURE_CREDENTIALS).[6][8][9]
3. Umgang mit Secrets (OpenAI API Key)
Meine Anwendung benötigt einen OpenAI API Key. Dieser darf nicht im Code oder im Docker-Image hardcodiert sein.
Gib mir Anweisungen, wie ich diesen API-Key als Umgebungsvariable in meiner Azure Container App sicher hinterlegen kann.[10][11]
Stelle sicher, dass mein Anwendungscode so konfiguriert ist, dass er den API-Key aus den Umgebungsvariablen liest (z.B. process.env.OPENAI_API_KEY).
4. Anleitung für manuelle Schritte
Bitte erstelle eine DEPLOYMENT_ANLEITUNG.md Datei mit einer schrittweisen Anleitung für die folgenden manuellen Schritte, die ich durchführen muss:
In Azure:
Erstellung einer Azure Container Registry (ACR), um meine Docker-Images zu speichern.
Erstellung einer Azure Container App (oder Web App for Containers) als Ziel für mein Deployment.
Erstellung eines Service Principals mit den notwendigen Berechtigungen, um das Deployment durchzuführen.[9]
Konfiguration der Umgebungsvariable für den OPENAI_API_KEY in der Azure Container App.[10]
In GitHub:
Erstellung eines neuen GitHub-Repositorys und Pushen meines Replit-Codes dorthin.
Einrichtung der notwendigen GitHub Secrets (ACR_USERNAME, ACR_PASSWORD, AZURE_CREDENTIALS), die vom GitHub Actions Workflow verwendet werden.[8][9]
Bitte sei bei der Erstellung der Dateien und Anleitungen so detailliert wie möglich, damit ich den Prozess reibungslos durchführen kann.
Was dieser Prompt bewirkt
Klarheit: Der Prompt gibt der Replit-KI eine sehr klare und strukturierte Aufgabe. Er zerlegt die komplexe Anforderung in kleinere, überschaubare Teile.
Vollständigkeit: Er deckt alle notwendigen Aspekte ab: die Anwendung selbst (Dockerfile), den Automatisierungsprozess (GitHub Actions), die Sicherheit (Secrets) und die notwendigen manuellen Schritte (Anleitung).
Best Practices: Der Prompt fragt explizit nach bewährten Methoden, wie der manuellen Installation von Chromium im Docker-Container, um häufige Probleme mit Puppeteer in containerisierten Umgebungen zu vermeiden.[4][5][12]
Automatisierung: Der Fokus liegt auf einem vollautomatisierten CI/CD-Prozess mit GitHub Actions, was für moderne Softwareentwicklung entscheidend ist.